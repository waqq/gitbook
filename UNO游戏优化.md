# H5游戏优化与问题解决

#### 一、架构层优化

###### 1、模块化开发——提高开发效率，提高开发协作

uno是利用fis搭建的，项目结构比较简单，逻辑处理与界面代码都是融合在一起，代码结构很乱，没有进行模块化开发，一个新功能来了，经常会出现需要去修改老的模块的功能，然后功能迭代时需要去处理别的功能的代码

优化：
模块划分+数据存储+逻辑处理+事件驱动+规范化

首先以一个游戏场景作为一个模块，每个模块包含数据管理器、逻辑控制器、界面渲染器。

1. 逻辑控制器控制该模块的数据交互和模块间交互；
2. 数据管理器负责该模块的数据存储与数据处理；
3. 界面渲染器负责模块界面渲染与交互。

每个模块的数据管理器和逻辑控制器是在一开始就初始化的，所以会有很多地方需要进行模块间交互，这时一开始是需要进行目标存不存在的判断，改成事件驱动后就不需要进行这样的判断，减少了模块间的代码耦合

项目规范化，提高代码的可读性和可维护性，包含代码规范化和模块结构规范化

###### 2、游戏加载优化

一开始游戏加载机制是 zip包加载+分大模块加载（首包+通用包+场景包）

这样的加载方式存在很多问题，比如首包、通用包很大，导致进入游戏慢、zip解压失败后游戏界面显示异常等等问题

后来优化成 图集加载+按需加载（首包+通用包+场景包+弹窗包）

**优化的好处：**

1. 避免zip包解压失败，导致某些图片加载失败；
2. 提高进入游戏速度，按需加载减少了首包和通用包体积从而加快了打开游戏的速度
3. 避免不必要的加载，把场景资源和弹窗资源分开，当打开弹窗时才去加载

后续优化：

1. 适度释放资源加载  
2. 深入按需加载 比如在加载前根据数据去判断需要具体加载某个特效

###### 3、动画开发工具搭建

phaser是一款轻量级的2D游戏引擎，官方没有提供可视化的UI编辑器，界面所有的开发都是通过js来搭建出来，在开发动画时非常影响开发效率，并且开发出来的动效往往不能满足美术的需求，需要经过反复的调整。

后来借鉴Laya的动画制作机制，实现动效预览，所见即所得。
在laya的动画编辑器中将动画在timeline中编辑好，导出包含每帧动画节点所处状态的json文件，
然后通过解析脚本通过phaser的tween将每帧衔接到一起，这样实现最后的动画。

做了这个动画制作工具后，美术可以再laya的动画编辑器中将动画制作到他们满意的程度，然后我们只需要稍作修改，符合项目需求就能实现之前需要程序花很长时间才达到的效果

我觉得这个工具或者说这一套动画制作思路 以后在别的不支持动画编辑的引擎也是适用的

###### **4、组件开发**

- scroller组件
- input组件

input组件不是很复杂，但是在一开始没有这个组件时，团队在评定需求时都会把用户输入的需求否定掉，因为canvas没有输入框，phaser也没有做相关封装。在产品决定做聊天功能时，我想到可以利用HTML 的input，监听input标签输入来更新游戏界面内的假input，然后做了这个组件，并且支持了大部分html input标签的功能。
后续维护：实现input在游戏界面之上，处理尺寸、位置等问题，这样有个好处是不用去实现哪些input自带的功能，还能把输入条显示在输入框的底部

scroller组件是为了提高界面渲染性能去开发的，很出现多个相似元素的列表时，界面渲染会消耗很长时间，组件的设计思路大致是 代码只初始化比可视区域多2-到3个元素，然后在滚动过程中，把离开可是区域的元素移动到即将进入可视区域的位置，同时根据不同数据来更新元素的表现。
后续维护：需要把元素高度 位置不一致的情况考虑到组件当中

###### 4、图片渲染

在平时开发中，美术经常会给一些周边留白很多的透明图片，之前是直接放进资源包中加载使用，因为透明部分不会影响资源大小，但后来发现在浏览器渲染图片时，透明像素点也会消耗浏览器的内存，后来在打包图集时，把留白去掉了，phaser根据资源在图集中的trimmed属性会选择留白渲染

6、九宫格报错

phaser在创建一个sprite对象时，如果没有给这个sprite指定texture材质的话 phaser会给这个对象一个default材质 这个是引擎去load的一个用base64形式 写在代码中的一个资源
如果代码中指定了texture 但是在资源cache中没有找到 phaser同样会给这个对象一个 missing材质 这个也是默认加载的

我们的九宫格使用的是phaser的九宫格插件，这个插件在销毁一个没有在cache中找到资源的 sprite时，会把cache中的missing也移除了 导致后面再次渲染一个没有找到资源的sprite时，就会报出getimgdata的错

7、分享（离屏canvas）

需求是 分享一张显示玩家具体数据的图片，这个图片是动态拼接的，然后主界面一开始并不需要显示出来，所以考虑可以用离屏canvas来实现 创建一个不显示的canvas，然后在这个canvas中去渲染出符合要求的分享图，然后通过todataurl来拿到分享图数据

8、减少drawcall （call draw 越小越好）

canvas的drawcall 是每帧调用draw（绘制）的次数

webgl的drawcall 表示 渲染提交批次 每次把数据通知到GPU渲染绘制的过程为1个drawcall

优化drawcall 可以通过 设置复杂节点的cacheas来减少

